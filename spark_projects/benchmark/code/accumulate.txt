-- start file accumulate_p.adb

package body Accumulate_P with
   Spark_Mode
 is

   function Accumulate
     (A    : T_Arr;
      Init : T)
      return T
   is
      Result : T := Init;
   begin
      for J in A'Range loop
         pragma Assert (Acc_Def (A, A'First, J, Init).OK);
         Result := Result + A (J);
         pragma Loop_Invariant (Result = Acc_Def (A, A'First, J, Init).Value);

      end loop;

      return Result;
   end Accumulate;
end Accumulate_P;

-- end file accumulate_p.adb


-- start file accumulate_p.ads

with Types;     use Types;
with Acc_Def_P; use Acc_Def_P;

package Accumulate_P with
   Spark_Mode
 is

   function Accumulate
     (A    : T_Arr;
      Init : T)
      return T with
      Pre  => (for all J in A'Range => Acc_Def (A, A'First, J, Init).OK),
      Post => Accumulate'Result = Acc_Def (A, A'First, A'Last, Init).Value;

end Accumulate_P;

-- end file accumulate_p.ads


-- start file acc_def_p.ads

with Types;    use Types;
with Overflow; use Overflow;

package Acc_Def_P with
   Spark_Mode,
   Ghost
 is

   function Acc_Def_Rec
     (A    : T_Arr;
      F, L : Integer;
      Init : T)
      return T_Option is
     (if L < F then (True, Init)
      else
        (if
           Acc_Def_Rec (A, F, L - 1, Init).OK
           and then Add_No_Overflow
             (Acc_Def_Rec (A, F, L - 1, Init).Value, A (L))
         then (True, Acc_Def_Rec (A, F, L - 1, Init).Value + A (L))
         else (OK => False))) with
      Pre => (if L >= F then L in A'Range and F in A'Range);
   pragma Annotate (Gnatprove, Terminating, Acc_Def_Rec);

   function Acc_Def
     (A    : T_Arr;
      F, L : Integer;
      Init : T)
      return T_Option is (Acc_Def_Rec (A, F, L, Init)) with
      Pre => (if L >= F then L in A'Range and F in A'Range);

end Acc_Def_P;

-- end file acc_def_p.ads


-- start file types.ads

package Types is

   type T is new Integer;

   type T_Arr is array (Positive range <>) of T;

   type T_Option (OK : Boolean) is record
      case OK is
         when True =>
            Value : T;
         when False =>
            null;
      end case;
   end record;

   MAX_SIZE : constant := 1000;

   type Option (Exists : Boolean := False) is record
      case Exists is
         when True =>
            Value : Integer;
         when False =>
            null;
      end case;
   end record;

   type Option_Pair (Exists : Boolean := False) is record
      case Exists is
         when True =>
            Lower : Integer;
            Upper : Integer;
         when False =>
            null;
      end case;
   end record;

   type Heap is record
      A    : T_Arr (1 .. MAX_SIZE) := (others => 0);
      Size : Natural               := 0;
   end record;

end Types;

-- end file types.ads


-- start file overflow.adb

package body Overflow with
   Spark_Mode
 is

   function Multiply_No_Overflow
     (X, Y : T)
      return Boolean
   is
      Res : Boolean;
   begin
      case X is
         when 0 =>
            Res := True;
         when -1 =>
            Res := Y /= T'First;
         when T'First .. -2 =>
            Res := Y in T'Last / X .. T'First / X;
            pragma Assert (if Y < T'Last / X - 1 then X * Y > T'Last);
            pragma Assert (if Y < T'Last / X then X * Y > T'Last);
         when 1 .. T'Last =>
            Res := Y in T'First / X .. T'Last / X;
            pragma Assert (if Y < T'First / X - 1 then X * Y < T'First);
            pragma Assert (if Y < T'First / X then X * Y < T'First);
      end case;
      return Res;
   end Multiply_No_Overflow;

end Overflow;

-- end file overflow.adb


-- start file overflow.ads

with Types; use Types;

package Overflow with
   Spark_Mode,
   Ghost
 is

   function Add_No_Overflow
     (X, Y : T)
      return Boolean is
     (Y = 0 or else (Y > 0 and then T'Last - Y >= X)
      or else (Y < 0 and then T'First - Y <= X));

   function Minus_No_Overflow
     (X, Y : T)
      return Boolean is
     (Y = 0 or else (Y < 0 and then T'Last + Y >= X)
      or else (Y > 0 and then T'First + Y <= X));

   function Multiply_No_Overflow
     (X, Y : T)
      return Boolean with
      Contract_Cases => ((X * Y in T) => Multiply_No_Overflow'Result = True,
       others => Multiply_No_Overflow'Result = False);

end Overflow;

-- end file overflow.ads