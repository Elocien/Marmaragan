-- start file iota_p.adb

package body Iota_P with
   Spark_Mode
 is
   procedure Iota
     (A   : in out T_Arr;
      Val :        T)
   is
      Count : T := Val;
   begin
      for I in A'Range loop
         A (I) := Count;
         Count := Count + 1;
         pragma Loop_Invariant (Count = Val + T (I - A'First + 1));
         pragma Loop_Invariant (Is_Iota (A (A'First .. I), Val));
      end loop;
   end Iota;
end Iota_P;

-- end file iota_p.adb


-- start file iota_p.ads

with Types;     use Types;
with Is_Iota_P; use Is_Iota_P;

package Iota_P with
   Spark_Mode
 is
   procedure Iota
     (A   : in out T_Arr;
      Val :        T) with
      Pre  => Val + A'Length <= T'Last,
      Post => Is_Iota (A, Val);
end Iota_P;

-- end file iota_p.adb


-- start file types.ads

package Types is

   type T is new Integer;

   type T_Arr is array (Positive range <>) of T;

   type T_Option (OK : Boolean) is record
      case OK is
         when True =>
            Value : T;
         when False =>
            null;
      end case;
   end record;

   MAX_SIZE : constant := 1000;

   type Option (Exists : Boolean := False) is record
      case Exists is
         when True =>
            Value : Integer;
         when False =>
            null;
      end case;
   end record;

   type Option_Pair (Exists : Boolean := False) is record
      case Exists is
         when True =>
            Lower : Integer;
            Upper : Integer;
         when False =>
            null;
      end case;
   end record;

   type Heap is record
      A    : T_Arr (1 .. MAX_SIZE) := (others => 0);
      Size : Natural               := 0;
   end record;

end Types;

-- end file types.ads


-- start file is_iota_p.ads

with Types; use Types;

package Is_Iota_P with
   Spark_Mode,
   Ghost
 is
   function Is_Iota
     (A   : T_Arr;
      Val : T)
      return Boolean is
     (for all I in A'Range => A (I) = Val + T (I - A'First)) with
      Pre => Val + A'Length <= T'Last;
end Is_Iota_P;

-- end file is_iota_p.ads