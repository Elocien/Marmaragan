-- start file search_n_p.adb

package body Search_N_P with
   Spark_Mode
 is

   function Search_N
     (A   : T_Arr;
      Val : T;
      N   : Positive)
      return Option
   is
      Result : Option   := (Exists => False);
      Start  : Positive := A'First;
   begin
      if A'Length < N then
         return Result;
      end if;

      for I in A'Range loop
         if A (I) /= Val then
            Start := I + 1;
         elsif I + 1 - Start = N then
            Result := (Exists => True, Value => Start);

            return Result;
         end if;

         pragma Loop_Invariant (not Result.Exists);
         pragma Loop_Invariant (Start in A'First .. I + 1);
         pragma Loop_Invariant
           (if Start <= I then
              Constant_Range_From_Location (A, Val, Start, I + 1 - Start));
         pragma Loop_Invariant
           (not Has_Constant_Subrange (A (A'First .. I), Val, N));
         pragma Loop_Invariant (if Start > A'First then A (Start - 1) /= Val);
      end loop;

      return Result;

   end Search_N;
end Search_N_P;

-- end file search_n_p.adb


-- start file search_n_p.ads

with Types;                   use Types;
with Has_Constant_Subrange_P; use Has_Constant_Subrange_P;

package Search_N_P with
   Spark_Mode
 is

   function Search_N
     (A   : T_Arr;
      Val : T;
      N   : Positive)
      return Option with
      Pre            => A'First <= A'Last and then A'Last < Positive'Last,
      Contract_Cases =>
      (Has_Constant_Subrange (A, Val, N) =>
         Search_N'Result.Exists and then Search_N'Result.Value >= A'First
         and then Search_N'Result.Value <= A'Last - N + 1
         and then Constant_Range_From_Location
           (A, Val, Search_N'Result.Value, N)
         and then
         (if Search_N'Result.Value > A'First then
            not Has_Constant_Subrange
              (A (A'First .. Search_N'Result.Value + N - 2), Val, N)),
       others => not Search_N'Result.Exists);

end Search_N_P;

-- end file search_n_p.ads


-- start file types.ads

package Types is

   type T is new Integer;

   type T_Arr is array (Positive range <>) of T;

   type T_Option (OK : Boolean) is record
      case OK is
         when True =>
            Value : T;
         when False =>
            null;
      end case;
   end record;

   MAX_SIZE : constant := 1000;

   type Option (Exists : Boolean := False) is record
      case Exists is
         when True =>
            Value : Integer;
         when False =>
            null;
      end case;
   end record;

   type Option_Pair (Exists : Boolean := False) is record
      case Exists is
         when True =>
            Lower : Integer;
            Upper : Integer;
         when False =>
            null;
      end case;
   end record;

   type Heap is record
      A    : T_Arr (1 .. MAX_SIZE) := (others => 0);
      Size : Natural               := 0;
   end record;

end Types;

-- end file types.ads


-- start file has_constant_subrange_p.ads

with Types; use Types;

package Has_Constant_Subrange_P with
   Spark_Mode,
   Ghost
 is

   function Constant_Range_From_Location
     (A      : T_Arr;
      Val    : T;
      Loc    : Positive;
      Length : Positive)
      return Boolean is
     (Loc - 1 + Length <= A'Last
      and then (for all I in Loc .. Loc - 1 + Length => A (I) = Val)) with
      Pre => Loc >= A'First and then Loc <= A'Last - Length + 1
      and then Loc - 1 + Length <= Positive'Last;

   function Has_Constant_Subrange
     (A   : T_Arr;
      Val : T;
      N   : Positive)
      return Boolean is
     (for some I in A'First .. A'Last - N + 1 =>
        Constant_Range_From_Location (A, Val, I, N)) with
      Pre => A'First <= A'Last;

end Has_Constant_Subrange_P;

-- end file has_constant_subrange_p.ads