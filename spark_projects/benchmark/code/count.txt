-- start file count_p.adb

package body Count_P with
   Spark_Mode
 is

   function Count
     (A   : T_Arr;
      Val : T)
      return Natural
   is
      Result : Natural := 0;
   begin
      for I in A'Range loop
         if A (I) = Val then
            Result := Result + 1;
         end if;

         pragma Loop_Invariant (Result <= A'Length);
         pragma Loop_Invariant (Result = Occ (A (A'First .. I), Val));
      end loop;

      return Result;
   end Count;
end Count_P;

-- end file count_p.adb


-- start file count_p.ads

with Types; use Types;
with Occ_P; use Occ_P;

package Count_P with
   Spark_Mode
 is

   function Count
     (A   : T_Arr;
      Val : T)
      return Natural with
      Post =>
      (Count'Result <= A'Length and then Count'Result in 0 .. A'Length
       and then Count'Result = Occ (A, Val));

end Count_P;

-- end file count_p.ads


-- start file types.ads

package Types is

   type T is new Integer;

   type T_Arr is array (Positive range <>) of T;

   type T_Option (OK : Boolean) is record
      case OK is
         when True =>
            Value : T;
         when False =>
            null;
      end case;
   end record;

   MAX_SIZE : constant := 1000;

   type Option (Exists : Boolean := False) is record
      case Exists is
         when True =>
            Value : Integer;
         when False =>
            null;
      end case;
   end record;

   type Option_Pair (Exists : Boolean := False) is record
      case Exists is
         when True =>
            Lower : Integer;
            Upper : Integer;
         when False =>
            null;
      end case;
   end record;

   type Heap is record
      A    : T_Arr (1 .. MAX_SIZE) := (others => 0);
      Size : Natural               := 0;
   end record;

end Types;

-- end file types.ads


-- start file occ_p.ads

with Types;     use Types;
with Occ_Def_P; use Occ_Def_P;

package Occ_P with
   Spark_Mode,
   Ghost
 is
   function Occ
     (A   : T_Arr;
      Val : T)
      return Natural is (Occ_Def (A, Val)) with
      Post => Occ'Result <= A'Length;

end Occ_P;

-- end file occ_p.ads


-- start file occ_def_p.ads

with Types; use Types;
package Occ_Def_P with
   Spark_Mode,
   Ghost
 is

   function Remove_Last
     (A : T_Arr)
      return T_Arr is (A (A'First .. A'Last - 1)) with
      Pre => A'Length > 0,
      Ghost;

   function Occ_Def
     (A   : T_Arr;
      Val : T)
      return Natural is
     (if A'Length = 0 then 0
      elsif A (A'Last) = Val then Occ_Def (Remove_Last (A), Val) + 1
      else Occ_Def (Remove_Last (A), Val)) with
      Post => Occ_Def'Result <= A'Length;
   pragma Annotate (Gnatprove, Terminating, Occ_Def);
end Occ_Def_P;

-- end file occ_def_p.ads